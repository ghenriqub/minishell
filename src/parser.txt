/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   main.c                                             :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ghenriqu <ghenriqu@student.42porto.com>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/03 21:33:12 by lgertrud          #+#    #+#             */
/*   Updated: 2025/07/12 14:13:44 by ghenriqu         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

/// @brief Read line, create history, check signal ctrl-C and call tokenizer
/// @return value exit
int	main(int argc, char **argv, char **env)
{
	char	*line;
	t_token	*tokens;

	(void)argc;
	(void)argv;
	ft_setup_signals();
	while (1)
	{
		line = readline("minishell$ ");
		if (!line)
			break ;
		if (*line)
			add_history(line);
		tokens = ft_tokenizer(line, env);
		free(line);
		ft_free_tokens(tokens);
	}
	rl_clear_history();
	return (0);
}

/// @brief Handles the SIGINT signal (Ctrl-C) by clearing the current input line
///        and redisplaying the prompt without exiting the shell.
/// @param sig The signal number (unused in this function).
void	ft_handle_sigint(int sig)
{
	(void)sig;
	rl_replace_line("", 0);
	write(1, "\n", 1);
	rl_on_new_line();
	rl_redisplay();
}

/// @brief Sets up custom signal handlers for interactive shell behavior.
///        Specifically, handles SIGINT and ignores SIGQUIT.
/// @param void This function takes no parameters.
void	ft_setup_signals(void)
{
	signal(SIGINT, ft_handle_sigint);
	signal(SIGQUIT, SIG_IGN);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   parser_to_builtins.c                               :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ghenriqu <ghenriqu@student.42porto.com>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/11 13:13:19 by lgertrud          #+#    #+#             */
/*   Updated: 2025/07/12 17:07:06 by ghenriqu         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

/// @brief this function call ant builtin according to input
/// @param token tokens of the input
/// @param env variable ambient 
/// @return return 1 if succed, or 0 if is fail
int	call_builtins(t_token *token, t_shell *shell, char **env)
{
	char	**args;

	args = ft_array_struct(token);
	if (!ft_strncmp(token->value, "pwd", 3) && ft_strlen(token->value) == 3)
	{
		ft_pwd(args);
		ft_free_split(args);
		return (1);
	}
	if (!ft_strncmp(token->value, "echo", 4) && ft_strlen(token->value) == 4)
	{
		ft_echo(args, shell->exit_status);
		ft_free_split(args);
		return (1);
	}
	if (!ft_strncmp(token->value, "env", 3) && ft_strlen(token->value) == 3)
	{
		ft_env(args, env);
		ft_free_split(args);
		return (1);
	}
	ft_free_split(args);
	return (0);
}

/// @brief This function create the array of the args,
/// 		but without the command name
///				exemple: "echo hello", return args[0] = hello
/// @param token struct where is the args.
/// @return array of the args.
char	**ft_array_struct(t_token *token)
{
	char	**args;
	int		i;
	int		len;

	len = ft_lstsize(token);
	i = 0;
	args = malloc(sizeof(char *) * len);
	if (!args)
		return (NULL);
	if (len == 1)
	{
		args[0] = NULL;
		return (args);
	}
	token = token ->next;
	while (token)
	{
		args[i] = ft_strdup(token->value);
		token = token->next;
		i++;
	}
	args[i] = NULL;
	return (args);
}

/// @brief free any array of the arrays
/// @param arr array of the arrays
void	ft_free_split(char **arr)
{
	int	i;

	i = 0;
	while (arr[i])
	{
		free(arr[i]);
		i++;
	}
	free(arr);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   token.c                                            :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: lgertrud <lgertrud@student.42porto.com>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/08 18:25:51 by lgertrud          #+#    #+#             */
/*   Updated: 2025/07/11 17:00:51 by lgertrud         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

static int	ft_init_token_2(t_token *new, t_token *head, char *line, int *i);
static void	ft_init_token_3(t_token **new, t_token **head, t_token **current);

void		print_token(t_token *token);

/// @brief init token and call built functons
/// @param line is the param that user write
/// @param env ambient variable
/// @return the token created
t_token	*ft_tokenizer(char *line, char **env)
{
	t_token	*token;

	if (!line[0])
		return (NULL);
	token = ft_init_token(line);
	if (!token)
	{
		printf(INPUT_ERROR);
	}
	else
		call_builtins(token, env);
	return (token);
}

/// @brief tokenization, alloc the memory and call functions for value and type
/// @param line is the user input
/// @return return token created or NULL if input is invalid
t_token	*ft_init_token(char *line)
{
	t_token	*head;
	t_token	*current;
	t_token	*new;
	int		i;

	head = NULL;
	current = NULL;
	i = 0;
	while (line[i])
	{
		if (line[i] == ' ' || line[i] == '\t')
			i++;
		else
		{
			new = malloc(sizeof(t_token));
			if (!new)
				ft_error(head, MALLOC_ERROR, 1);
			if (!ft_init_token_2(new, head, line, &i))
				return (NULL);
			ft_init_token_3(&new, &head, &current);
		}
	}
	return (head);
}

/// @brief if the atual character is a delimiter, created a token
/// 		else, call function get value.
/// @param new is a new node
/// @param head head to linked list
/// @param line input user
/// @param i interator that we used to walk string
/// @return return 0 for error or 1 if was been succeed
static int	ft_init_token_2(t_token *new, t_token *head, char *line, int *i)
{
	if ((line[*i] == '>' && line[*i + 1] == '>')
		|| (line[*i] == '<' && line[*i + 1] == '<'))
	{
		new->value = ft_substr(line, *i, 2);
		(*i)++;
		(*i)++;
	}
	else if (ft_is_delimiter(line[*i]))
	{
		new->value = ft_substr(line, (*i), 1);
		(*i)++;
	}
	else
		new->value = ft_get_value(line, i);
	if (!new->value)
	{
		ft_free_tokens(head);
		free(new);
		return (0);
	}
	return (1);
}

/// @brief call the get type and update current
/// @param new new node
/// @param head declare head, if it has not been declared
/// @param current variable used to walk inside list
static void	ft_init_token_3(t_token **new, t_token **head, t_token **current)
{
	(*new)->type = ft_get_type((*new)->value);
	(*new)->next = NULL;
	if (!*head)
	{
		*head = *new;
		*current = *new;
	}
	else
	{
		(*current)->next = *new;
		*current = *new;
	}
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   token_utils.c                                      :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: lgertrud <lgertrud@student.42porto.com>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/10 16:48:31 by lgertrud          #+#    #+#             */
/*   Updated: 2025/07/10 20:58:50 by lgertrud         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

static char	*ft_get_value_2(const char *s, int *i);

/// @brief Extracts the next token
///			(word or quoted string) from the input string.
/// @param s The input string to parse.
/// @param i A pointer to the current position in the string (will be updated).
/// @return A newly allocated substring containing the extracted token.
char	*ft_get_value(const char *s, int *i)
{
	char	*result;
	char	*part;
	char	*tmp;

	result = NULL;
	while (s[*i] && s[*i] != ' ' && s[*i] != '\t' && !ft_is_delimiter(s[*i]))
	{
		part = ft_get_value_2(s, i);
		if (!part)
		{
			free(result);
			return (NULL);
		}
		tmp = result;
		if (result)
			result = ft_strjoin(result, part);
		else
			result = ft_strdup(part);
		free(tmp);
		free(part);
	}
	return (result);
}

/// @brief Extracts a single token part:
///			either a quoted string or a plain word fragment.
///       	 Handles opening/closing quotes and
///				advances the parsing index accordingly.
/// @param s The input string being parsed.
/// @param i A pointer to the current index in the string. Will be updated.
/// @return A newly allocated substring for this part
///				or NULL if unterminated quote or malloc fails.
static char	*ft_get_value_2(const char *s, int *i)
{
	int		start;
	char	quote;
	char	*part;

	if (s[*i] == '"' || s[*i] == '\'')
	{
		quote = s[(*i)++];
		start = *i;
		while (s[*i] && s[*i] != quote)
			(*i)++;
		if (s[*i] != quote)
			return (NULL);
		part = ft_substr(s, start, (*i) - start);
		(*i)++;
	}
	else
	{
		start = *i;
		while (s[*i] && s[*i] != '"' && s[*i] != '\''
			&& s[*i] != ' ' && s[*i] != '\t' && !ft_is_delimiter(s[*i]))
			(*i)++;
		part = ft_substr(s, start, *i - start);
	}
	return (part);
}

/// @brief this functions define the type of the value
/// @param value value of type that we will find
/// @return The type of the argument
t_type	ft_get_type(char *value)
{
	if (!ft_strncmp(">", value, ft_strlen(value)) && value[0])
		return (T_REDIRECT_OUT);
	else if (!ft_strncmp(">>", value, ft_strlen(value)) && value[0])
		return (T_APPEND);
	else if (!ft_strncmp("<", value, ft_strlen(value)) && value[0])
		return (T_REDIRECT_IN);
	else if (!ft_strncmp("|", value, ft_strlen(value)) && value[0])
		return (T_PIPE);
	else if (!ft_strncmp("<<", value, ft_strlen(value)) && value[0])
		return (T_HEREDOC);
	else
		return (T_WORD);
}

/// @brief if the param is a delimiter, return 1 else 0
int	ft_is_delimiter(char c)
{
	return (c == '>' || c == '<' || c == '|');
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   utils.c                                            :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: lgertrud <lgertrud@student.42porto.com>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/09 19:54:58 by lgertrud          #+#    #+#             */
/*   Updated: 2025/07/11 16:03:17 by lgertrud         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

/// @brief free struct
void	ft_free_tokens(t_token *token)
{
	t_token	*tmp;

	while (token)
	{
		tmp = token->next;
		if (token->value)
			free(token->value);
		free(token);
		token = tmp;
	}
}

/// @brief function for errors
/// @param token token for free
/// @param message message error
/// @param code exit code
void	ft_error(t_token *token, char *message, int code)
{
	if (token)
		ft_free_tokens(token);
	ft_putendl_fd(message, 2);
	exit (code);
}

/// @brief this function counts how many nodes there are in a struct
/// @param env ambient variable
/// @return the count
int	ft_lstsize(t_token *lst)
{
	int	i;

	i = 0;
	while (lst)
	{
		lst = lst->next;
		i++;
	}
	return (i);
}

// provisorie function, we will delete it latter
char	*name_type(int type)
{
	if (type == 0)
		return ("WORD");
	if (type == 1)
		return ("PIPE");
	if (type == 2)
		return ("REDIRECT_IN");
	if (type == 3)
		return ("REDIRECT_OUT");
	if (type == 4)
		return ("APPEND");
	return ("HEREDOC");
}

// provisorie function, we will delete it latter
void	print_token(t_token *token)
{
	t_token	*current;
	int		i;

	current = token;
	i = 0;
	printf("------------------------\n");
	printf("-------TOKENS-----------\n");
	printf("------------------------\n");
	while (current)
	{
		printf("TOKEN[%d]\n", i);
		printf("value -> %s\n", current->value);
		printf("type -> %s\n", name_type(current->type));
		printf("-----------\n");
		i++;
		current = current->next;
	}
}
