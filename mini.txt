/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   cd.c                                               :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: lgertrud <lgertrud@student.42porto.com>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/08 17:17:22 by ghenriqu          #+#    #+#             */
/*   Updated: 2025/08/21 11:06:27 by lgertrud         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"
#include <string.h>
#include <errno.h>

/// @brief the standard cd error message
/// @param path the path that were sent
static void	print_cd_error(char *path)
{
	ft_putstr_fd("cd: ", STDERR_FILENO);
	ft_putstr_fd(path, STDERR_FILENO);
	ft_putstr_fd(": ", STDERR_FILENO);
	ft_putstr_fd(strerror(errno), STDERR_FILENO);
	ft_putchar_fd('\n', STDERR_FILENO);
}

/// @brief the error message in case of too many args
/// @param args the arguments are passed as a returnable function
/// @return 1 after the message sent
static int	handle_many_args(void)
{
	ft_putstr_fd("cd: too many arguments\n", STDERR_FILENO);
	return (1);
}

/// @brief free the variables in the main cd function
/// @param old the old pwd
/// @param new the new pwd
/// @param target and the targeted pwd
static void	free_cd(char *old, char *new, char *target)
{
	if (old)
		free(old);
	if (new)
		free(new);
	if (target)
		free(target);
	else
		return ;
}

/// @brief the function that emulates the cd function
/// @var pwd[0] = old_pwd, pwd[1] = new_pwd, pwd[2] = target_pwd
/// @param args the arguments we got from the readline input
/// @param shell the struct that holds our env variables
/// @return 0 = success and 1 = error
int	ft_cd(char **args, t_shell *shell)
{
	char	*pwd[3];
	int		result;

	if (!args)
		return (1);
	if (args[0] && args[1])
		return (handle_many_args());
	pwd[0] = get_current_dir();
	pwd[2] = get_target_dir(args, shell);
	if (!pwd[2])
	{
		free(pwd[0]);
		return (1);
	}
	result = chdir(pwd[2]);
	if (result == -1)
	{
		print_cd_error(pwd[2]);
		free_cd(pwd[0], NULL, pwd[2]);
		return (1);
	}
	pwd[1] = get_current_dir();
	update_pwd_env(pwd[0], pwd[1], shell);
	free_cd (pwd[0], pwd[1], pwd[2]);
	return (0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   cd_utils.c                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ghenriqu <ghenriqu@student.42porto.com>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/08 17:17:22 by ghenriqu          #+#    #+#             */
/*   Updated: 2025/07/13 15:36:54 by ghenriqu         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

/// @brief 
/// @param var 
/// @return 
static char	*target_error(char *var)
{
	ft_putstr_fd("cd: ", STDERR_FILENO);
	ft_putstr_fd(var, STDERR_FILENO);
	ft_putstr_fd(" not set\n", STDERR_FILENO);
	return (NULL);
}

/// @brief 
/// @param shell 
/// @param var 
/// @return 
static char	*get_env_var(t_shell *shell, const char *var)
{
	int		i;
	int		len;
	char	*env_var;

	i = 0;
	len = ft_strlen(var);
	if (!shell->env || !var)
		return (NULL);
	while (shell->env[i])
	{
		env_var = ft_strchr(shell->env[i], '=');
		if (env_var && (env_var - shell->env[i]) == len)
		{
			if (ft_strncmp(shell->env[i], var, len) == 0)
				return (env_var + 1);
		}
		i++;
	}
	return (NULL);
}

/// @brief 
/// @param args 
/// @param shell 
/// @return 
char	*get_target_dir(char **args, t_shell *shell)
{
	char	*target;
	char	*env_value;

	if (!args[0])
	{
		env_value = get_env_var(shell, "HOME");
		if (!env_value)
			return (target_error("HOME"));
		target = ft_strdup(env_value);
	}
	else if (ft_strncmp(args[0], "-", 1) == 0)
	{
		env_value = get_env_var(shell, "OLDPWD");
		if (!env_value)
			return (target_error("OLDPWD"));
		target = ft_strdup(env_value);
		ft_putstr_fd(target, STDOUT_FILENO);
		ft_putchar_fd('\n', STDOUT_FILENO);
	}
	else
		target = ft_strdup(args[0]);
	return (target);
}

/// @brief 
/// @param shell 
/// @param name 
/// @param path 
static void	set_env_var(t_shell *shell, char *name, char *path)
{
	char	*var;
	int		name_len;
	int		path_len;

	if (!name || !path || !shell)
		return ;
	name_len = ft_strlen(name);
	path_len = ft_strlen(path);
	var = malloc(sizeof(char) * (name_len + path_len + 2));
	if (!var)
		return ;
	ft_strlcpy(var, name, name_len + 1);
	ft_strlcat(var, "=", name_len + 2);
	ft_strlcat(var, path, name_len + path_len + 2);
	set_var(var, &(shell->env));
	free(var);
}

/// @brief 
/// @param old_pwd 
/// @param new_pwd 
/// @param shell 
void	update_pwd_env(char *old_pwd, char *new_pwd, t_shell *shell)
{
	if (old_pwd)
		set_env_var(shell, "OLDPWD", old_pwd);
	if (new_pwd)
		set_env_var(shell, "PWD", new_pwd);
	return ;
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   echo.c                                             :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ghenriqu <ghenriqu@student.42porto.com>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/08 17:17:26 by ghenriqu          #+#    #+#             */
/*   Updated: 2025/08/16 14:03:55 by ghenriqu         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

/// @brief we iterate until is a valid flag, 
/// @param arg the argument that should be verified 
/// @return 1 = valid flag || 0 = invalid flag
static int	n_flag(char *arg)
{
	int	i;

	if (!arg || arg[0] != '-')
		return (0);
	if (arg[1] != 'n')
		return (0);
	i = 1;
	while (arg[i])
	{
		if (arg[i] != 'n')
			return (0);
		i++;
	}
	return (1);
}

/// @brief the verification if the args are -n (-nnnn or -n -n too)
/// @param args the arguments we got from the STDIN_FILENO
/// @param new_line the variable that will tell if we'll have a nl or not
/// @return returns how many iterations we made until we got a valid string
static int	process_flags(char **args, int *new_line)
{
	int	i;

	i = 0;
	*new_line = 1;
	while (args[i] && n_flag(args[i]))
	{
		*new_line = 0;
		i++;
	}
	return (i);
}

/// @brief built-in echo implementation, with -n flag, whole string with write
/// @param args the arguments we got from the STDIN_FILENO
/// @return returns 0 on success (and it always succeeds)
int	ft_echo(char **args)
{
	int	new_line;
	int	i;

	if (!args || !args[0])
		return (0);
	i = process_flags(args, &new_line);
	while (args[i])
	{
		write (STDOUT_FILENO, args[i], ft_strlen(args[i]));
		if (args[i + 1])
			write(STDOUT_FILENO, " ", 1);
		i++;
	}
	if (new_line)
		write(STDOUT_FILENO, "\n", 1);
	return (0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   env.c                                              :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ghenriqu <ghenriqu@student.42porto.com>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/08 17:17:29 by ghenriqu          #+#    #+#             */
/*   Updated: 2025/08/02 16:23:44 by ghenriqu         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

/// @brief the standard error message of the wrong env call
/// @param arg the worng argument
static void	print_env_error(char *arg)
{
	ft_putstr_fd("env: ", STDERR_FILENO);
	ft_putstr_fd(arg, STDERR_FILENO);
	ft_putstr_fd(": too many arguments", STDERR_FILENO);
	ft_putstr_fd("\n", STDERR_FILENO);
}

/// @brief calculates the size of env 
/// @param env the local variables of the system
/// @return i = size of env
int	env_size(char **env)
{
	int	i;

	i = 0;
	while (env[i])
		i++;
	return (i);
}

/// @brief the built-in implementation of the env function
/// @param args the arguments we got in the readline
/// @param env the local variables of the system
/// @return 0 = success, 1 = error
int	ft_env(char **args, char **env)
{
	int	i;

	i = 0;
	if (args && args[0])
	{
		print_env_error(args[0]);
		return (1);
	}
	if (!env)
		return (0);
	while (env[i])
	{
		ft_putstr_fd(env[i], 1);
		ft_putchar_fd('\n', 1);
		i++;
	}
	return (0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   exit.c                                             :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ghenriqu <ghenriqu@student.42porto.com>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/08 17:17:33 by ghenriqu          #+#    #+#             */
/*   Updated: 2025/08/16 14:06:19 by ghenriqu         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

/// @brief the function that will print the standard exit error message
/// @param arg the arguments received at the call
/// @param type if its non-numeric or if its too many arguments
/// @param shell the shell structure with exit status
static void	print_exit_error(char *arg, int type, t_shell *shell)
{
	if (type == 1)
	{
		ft_putstr_fd("minishell: exit: ", STDERR_FILENO);
		ft_putstr_fd(arg, STDERR_FILENO);
		ft_putstr_fd(": numeric argument required\n", STDERR_FILENO);
	}
	else if (type == 2)
	{
		ft_putendl_fd("minishell: exit: too many arguments", STDERR_FILENO);
	}
	if (!arg)
		shell->exit_status = 1;
	return ;
}

/// @brief the free clean and error code of the exit call
/// @param args the arguments received at the call
/// @param shell the shell structure with exit status
/// @param exit_code the code we got to exit
/// @param token the tokenized structure with calls
static void	clean_exit(char **args, t_shell *shell,
		int exit_code, t_block *block)
{
	(void)args;
	shell->exit_status = exit_code;
	ft_free_split(shell->env);
	free(shell);
	ft_free_blocks(block);
	exit(exit_code & 255);
}

/// @brief the execution of the ft_exit in case of arg_count == 1
static void	ft_exit_one_arg(char **args, t_shell *sh, t_block *blk)
{
	long	exit_code;

	if (!is_valid_arg(args[0]) || (!ft_strncmp(args[0], "--", 2)))
	{
		if (!ft_strncmp(args[0], "--", 2))
			exit (0);
		print_exit_error(args[0], 1, sh);
		clean_exit(args, sh, 2, blk);
	}
	exit_code = ft_atoi(args[0]);
	clean_exit(args, sh, exit_code, blk);
}

/// @brief the built-in implementation of exit()
/// @param args the arguments that we will receive
/// @param shell the structure that hold some functionalities (exit status)
/// @param block 
/// @return 0 = success, 1 = error
int	ft_exit(char **args, t_shell *shell, t_block *block)
{
	int		arg_count;

	ft_putstr_fd("exit\n", 1);
	arg_count = count_args(args);
	if (arg_count == 0)
		clean_exit(args, shell, shell->exit_status, block);
	else if (arg_count == 1)
		ft_exit_one_arg(args, shell, block);
	else
	{
		if (!is_valid_arg(args[0]))
		{
			print_exit_error(args[0], 1, shell);
			clean_exit(args, shell, 2, block);
		}
		print_exit_error(NULL, 2, shell);
		return (1);
	}
	return (0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   exit_utils.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ghenriqu <ghenriqu@student.42porto.com>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/08 17:17:33 by ghenriqu          #+#    #+#             */
/*   Updated: 2025/08/16 12:18:00 by ghenriqu         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

/// @brief the classic count args
/// @param args the string that will hold the arguments
/// @return the number of arguments
int	count_args(char **args)
{
	int	count;

	count = 0;
	if (!args || !args[0])
		return (0);
	while (args[count])
		count++;
	return (count);
}

/// @brief verifies the validity of the argument with exit
/// @param arg the argument being analyzed
/// @return 1 = is valid, 0 = not valid
int	is_valid_arg(char *arg)
{
	unsigned long long	num[2];
	int					i[2];

	i[0] = 0;
	i[1] = 1;
	num[1] = 0;
	num[0] = LLONG_MAX;
	if (arg[i[0]] == '-' || arg[i[0]] == '+')
	{
		if (arg[i[0]] == '-')
			i[1] *= -1;
		i[0]++;
	}
	if (i[1] == -1)
		num[0] = (unsigned long long)LLONG_MAX + 1;
	while (arg[i[0]])
	{
		if (!ft_isdigit(arg[i[0]]))
			return (0);
		if (num[1] > (num[0] - (arg[i[0]] - '0')) / 10)
			return (0);
		num[1] = num[1] * 10 + (arg[i[0]] - '0');
		i[0]++;
	}
	return (1);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   export.c                                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: lgertrud <lgertrud@student.42porto.com>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/08 17:17:35 by ghenriqu          #+#    #+#             */
/*   Updated: 2025/08/21 14:24:25 by lgertrud         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

static void	ft_print_line(char *line)
{
	int	i;

	i = 0;
	do
	{
		write(1, &line[i], 1);
		i++;
	} while (line[i] && line[i - 1] != '=');
	if(!line[i] && line[i - 1] != '=')
	{
		write(1, "\n", 1);
		return ;
	}
	write(1, "\"", 1);
	while (line[i])
	{
		write(1, &line[i], 1);
		i++;
	}
	write(1, "\"\n", 2);
}

static void	print_export_error(char *arg)
{
	ft_putstr_fd("export: ", STDERR_FILENO);
	ft_putstr_fd(arg, STDERR_FILENO);
	ft_putstr_fd(": not a valid identifier\n", STDERR_FILENO);
}

static void	print_all(char **env)
{
	int	i;

	i = 0;
	while (env[i])
	{
		ft_putstr_fd("declare -x ", 1);
		ft_print_line(env[i]);
		i++;
	}
}

/// @brief the loop insife the export function
/// @param str[0] = equal sign
/// @param str[1] = command name
static void	ft_export_loop(char *arg, t_shell *shell, int *status)
{
	//char	*str[2];

	//str[0] = ft_strchr(arg, '=');
	//if (str[0])
	//{
	int	find;

	find = find_index(shell->export, arg);
	if (!is_valid(arg))
	{
		print_export_error(arg);
		*status = 1;
	}
	if(ft_strchr(arg, '='))
		set_var(arg, &shell->env);
	if(!ft_strchr(arg, '=')
		&& (find != -1 && ft_strchr(shell->export[find], '=')))
		return ;
	set_var(arg, &shell->export);
	//}
	// else if (!is_valid(arg))
	// {
	// 	print_export_error(arg);
	// 	*status = 1;
	// }
}

/// @param i[0] = iterator
/// @param i[1] = status
/// @return the status of the exit
int	ft_export(char **args, t_shell *shell)
{
	int		i[2];

	i[0] = 0;
	i[1] = 0;
	if (!args[i[0]])
	{
		print_all(shell->export);
		return (0);
	}
	while (args[i[0]])
	{
		ft_export_loop(args[i[0]], shell, &i[1]);
		i[0]++;
	}
	shell->exit_status = i[1];
	return (i[1]);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   export_utils.c                                     :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: lgertrud <lgertrud@student.42porto.com>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/08 17:17:35 by ghenriqu          #+#    #+#             */
/*   Updated: 2025/08/21 14:19:14 by lgertrud         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

/// @brief 
/// @param env 
/// @param variable 
/// @return 
int	find_index(char **env, char *variable)
{
	int	i;
	int	len;

	len = ft_strlen(variable);
	i = 0;
	while (env[i])
	{
		if (ft_strncmp(env[i], variable, len) == 0)
			return (i);
		i++;
	}
	return (-1);
}

/// @brief 
/// @param variable 
/// @return 
static char	*get_var(char *variable)
{
	int		i;
	char	*name;

	i = 0;
	while (variable[i] && variable[i] != '=')
		i++;
	name = malloc(sizeof(char) * (i + 1));
	if (!name)
		return (NULL);
	ft_strlcpy(name, variable, i + 1);
	return (name);
}

/// @brief 
/// @param variable 
/// @param env 
static void	set_env(char *variable, char ***env)
{
	char	**new_env;
	int		size;
	int		i;

	size = 0;
	i = 0;
	while ((*env)[size])
		size++;
	new_env = malloc(sizeof(char *) * (size + 2));
	if (!new_env)
		return ;
	while (i < size)
	{
		new_env[i] = (*env)[i];
		i++;
	}
	new_env[i] = ft_strdup(variable);
	new_env[i + 1] = NULL;
	free(*env);
	*env = new_env;
}

int	is_valid(char *str)
{
	int	i;

	i = 0;
	if (!str || !*str)
		return (0);
	if (!ft_isalpha(str[0]) && str[0] != '_')
		return (0);
	while (str[i] && str[i] != '=')
	{
		if (str[i] == '+' && str[i + 1] == '=')
			break ;
		if (!ft_isalnum(str[i]) && str[i] != '_')
			return (0);
		i++;
	}
	return (1);
}

/// @brief 
/// @param variable 
/// @param env 
void	set_var(char *variable, char ***env)
{
	char	*name;
	int		i;

	name = get_var(variable);
	i = find_index(*env, name);
	if (i != -1)
	{
		free((*env)[i]);
		(*env)[i] = ft_strdup(variable);
	}
	else
		set_env(variable, env);
	free(name);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   pwd.c                                              :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: lgertrud <lgertrud@student.42porto.com>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/08 17:17:38 by ghenriqu          #+#    #+#             */
/*   Updated: 2025/08/21 11:52:50 by lgertrud         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

/// @brief we just get the current directory with getcwd
/// @return the updated current working directory
char	*get_current_dir(void)
{
	char	*cwd;
	char	*temp;
	size_t	size;

	size = 1024;
	cwd = malloc(size);
	if (!cwd)
		return (NULL);
	while (getcwd(cwd, size) == NULL)
	{
		if (errno != ERANGE)
		{
			free (cwd);
			return (NULL);
		}
		size *= 2;
		temp = realloc(cwd, size);
		if (!temp)
		{
			free (cwd);
			return (NULL);
		}
		cwd = temp;
	}
	return (cwd);
}

static char	*get_pwd(char **envp)
{
	int	i;

	i = 0;
	while (envp[i])
	{
		if (!ft_strncmp(envp[i], "PWD=", 4))
			return (ft_strdup(envp[i] + 4));
		i++;
	}
	return (NULL);
}

/// @brief the built-in of the print working directory function
/// @param args the arguments received in the call
/// @return 0 = success, 1 = error
int	ft_pwd(char **args, char **envp)
{
	char	*cwd;

	(void)args;
	cwd = get_current_dir();
	if (!cwd)
	{
		cwd = get_pwd(envp);
		if (!cwd || ft_strlen(cwd) == 0)
		{
			ft_putendl_fd("pwd: error retrieving directory", STDERR_FILENO);
			return (1);
		}
	}
	ft_putstr_fd(cwd, STDOUT_FILENO);
	ft_putchar_fd('\n', STDOUT_FILENO);
	free(cwd);
	return (0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   unset.c                                            :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ghenriqu <ghenriqu@student.42porto.com>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/08 17:17:40 by ghenriqu          #+#    #+#             */
/*   Updated: 2025/08/16 17:21:35 by ghenriqu         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

/// @brief the standard error message of the unset command
/// @param arg the argument to be displayed 
static void	print_unset_error(char *arg)
{
	ft_putstr_fd("unset: ", STDERR_FILENO);
	ft_putstr_fd(arg, STDERR_FILENO);
	ft_putstr_fd(": invalid parameter name\n", STDERR_FILENO);
}

/// @brief the command finders, a ft_strcmp of the selected command
/// @param env the local variables
/// @param command the selected command
/// @return the index of the command, -1 in error
int	find_command(char **env, char *command)
{
	int	i;

	i = 0;
	while (env[i])
	{
		if (ft_strncmp(env[i], command, ft_strlen(command)) == 0
			&& env[i][ft_strlen(command)] == '=')
			return (i);
		i++;
	}
	return (-1);
}

/// @brief the split and update of the old variables into the updated
/// @param command the command that will be removed
/// @param env the local variables
static void	update_env(char *command, char ***env)
{
	int		i;
	int		j;
	char	**new_env;

	i = find_command(*env, command);
	if (i == -1)
		return ;
	new_env = malloc(sizeof(char *) * (env_size(*env) + 1));
	if (!new_env)
		return ;
	i = 0;
	j = 0;
	while ((*env)[i])
	{
		if (ft_strncmp((*env)[i], command, ft_strlen(command)))
			new_env[j++] = ft_strdup((*env)[i]);
		i++;
	}
	new_env[j] = NULL;
	ft_free_split(*env);
	*env = ft_copy_env(new_env);
	ft_free_split(new_env);
}

/// @brief we just verify the validity of the arguments
/// @param str the string that will be analyzed
/// @return 1 = is valid, 0 = not valid
static int	is_valid_unset(char *str)
{
	int	i;

	i = 0;
	if (!str || !*str)
		return (0);
	if (!ft_isalpha(str[0]) && str[0] != '_')
		return (0);
	while (str[i])
	{
		if (!ft_isalnum(str[i]) && str[i] != '_')
			return (0);
		i++;
	}
	return (1);
}

/// @brief the built-in implementation of bash unset function 
/// @param args the arguments we received in the call
/// @param shell the shell structure with the env variables
/// @return the status of the update
int	ft_unset(char **args, t_shell *shell)
{
	int	i;
	int	status;

	i = 0;
	status = 0;
	if (!shell->env)
		return (1);
	if (!args[0])
		return (0);
	while (args[i])
	{
		if (!is_valid_unset(args[i]))
		{
			print_unset_error(args[i]);
			status = 1;
		}
		else
			update_env(args[i], &shell->env);
		i++;
	}
	shell->exit_status = status;
	return (status);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   minishell.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: lgertrud <lgertrud@student.42porto.com>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/28 10:49:12 by lgertrud          #+#    #+#             */
/*   Updated: 2025/08/06 13:55:56 by lgertrud         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

void	ft_minishell(t_block *blocks, t_shell *shell)
{
	if (!blocks->next)
		ft_simple_command(blocks, shell);
	else
		ft_pipe_command(blocks, shell);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   path.c                                             :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: lgertrud <lgertrud@student.42porto.com>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/28 11:11:48 by lgertrud          #+#    #+#             */
/*   Updated: 2025/08/21 12:02:43 by lgertrud         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

static char	*get_path(char **envp)
{
	int	i;

	i = 0;
	while (envp[i])
	{
		if (!ft_strncmp(envp[i], "PATH=", 5))
		{
			return (envp[i] + 5);
		}
		i++;
	}
	return (NULL);
}

char	*ft_found_path(char *cmd, char **envp)
{
	char	**path;
	char	*path_cmd;
	int		i;

	if (access(cmd, X_OK) == 0)
		return (ft_strdup(cmd));
	i = 0;
	path = ft_split(get_path(envp), ':');
	if (!path)
		return (NULL);
	while (path[i])
	{
		path_cmd = ft_strjoin(path[i], "/");
		path_cmd = ft_join_free(path_cmd, cmd);
		if (access(path_cmd, X_OK) == 0)
		{
			ft_free_split(path);
			return (path_cmd);
		}
		free(path_cmd);
		i++;
	}
	ft_free_split(path);
	return (NULL);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   pipe.c                                             :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: lgertrud <lgertrud@student.42porto.com>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/08/01 11:00:50 by lgertrud          #+#    #+#             */
/*   Updated: 2025/08/21 14:41:19 by lgertrud         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

static void	ft_pipe_loop(t_block *blocks, t_shell *shell, pid_t *pids, int *i)
{
	int		pipefd[2];
	int		in_fd;

	in_fd = STDIN_FILENO;
	while (blocks)
	{
		if (blocks->next && pipe(pipefd) < 0)
			return (perror("pipe"));
		pids[*i] = fork();
		if (pids[*i] < 0)
			return (perror("fork"));
		else if (pids[*i] == 0)
		{
			signal(SIGINT, SIG_DFL);
			signal(SIGQUIT, SIG_DFL);
			ft_son(blocks, shell, in_fd, pipefd);
			ft_free_blocks(blocks);
			ft_free_split(shell->env);
			ft_free_split(shell->export);
			free(shell);
		}
		else
		{
			ft_father(blocks, &in_fd, pipefd);
		}
		blocks = blocks->next;
		(*i)++;
	}
}

void	ft_pipe_command(t_block *blocks, t_shell *shell)
{
	pid_t	pids[256];
	int		i;
	int		wstatus;

	i = 0;
	wstatus = 0;
	signal(SIGINT, SIG_IGN);
	signal(SIGQUIT, SIG_IGN);
	ft_pipe_loop(blocks, shell, pids, &i);
	ft_get_status(shell, i, pids, wstatus);
	signal(SIGINT, ft_handle_sigint);
	signal(SIGQUIT, SIG_IGN);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   pipe_utils.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: lgertrud <lgertrud@student.42porto.com>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/08/01 11:00:50 by lgertrud          #+#    #+#             */
/*   Updated: 2025/08/21 14:47:17 by lgertrud         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

void	ft_cmd(t_block *blocks, t_shell *shell)
{
	char	*path;

	path = NULL;
	if (!ft_call_builtins(blocks, shell))
	{
		path = ft_found_path(blocks->args[0], shell->env);
		if (execve(path, blocks->args, shell->env) == -1)
		{
			ft_putstr_fd(blocks->args[0], STDERR_FILENO);
			ft_putendl_fd(": command not found", STDERR_FILENO);
			ft_free_blocks(blocks);
			free(path);
			ft_free_split(shell->env);
			free(shell);
			shell->exit_status = 127;
			exit(127);
		}
	}
	if (path)
		free(path);
}

void	ft_son(t_block *blocks, t_shell *shell, int in_fd, int *pipefd)
{
	if (in_fd != STDIN_FILENO)
	{
		dup2(in_fd, STDIN_FILENO);
		close(in_fd);
	}
	if (blocks->next)
	{
		close(pipefd[0]);
		dup2(pipefd[1], STDOUT_FILENO);
		close(pipefd[1]);
	}
	if (!ft_redirections(blocks, shell))
		exit(1);
	ft_cmd(blocks, shell);
	exit(0);
}

void	ft_father(t_block *blocks, int *in_fd, int *pipefd)
{
	if (*in_fd != STDIN_FILENO)
		close(*in_fd);
	if (blocks->next)
	{
		close(pipefd[1]);
		*in_fd = pipefd[0];
	}
}

void	ft_get_status(t_shell *shell, int i, int *pids, int wstatus)
{
	int	j;

	j = 0;
	while (j < i)
	{
		waitpid(pids[j], &wstatus, 0);
		if (j == i - 1)
		{
			if (WIFEXITED(wstatus))
				shell->exit_status = WEXITSTATUS(wstatus);
			else if (WIFSIGNALED(wstatus))
				shell->exit_status = 128 + WTERMSIG(wstatus);
			else
				shell->exit_status = 1;
		}
		j++;
	}
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   redirections.c                                     :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: lgertrud <lgertrud@student.42porto.com>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/28 11:53:29 by lgertrud          #+#    #+#             */
/*   Updated: 2025/08/06 11:03:18 by lgertrud         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

static int	ft_red_here(t_block *block);
static int	ft_red_in(t_block *block, t_shell *shell);
static int	ft_red_out(t_block *block, t_shell *shell);
//cuidado com o leak, sempre chamar o ft_free com o primeiro node.

int	ft_redirections(t_block *block, t_shell *shell)
{
	int	ret;

	ret = 1;
	if (block->heredoc > 0)
		ret = ft_red_here(block);
	if (block->redirect_in > 0 && ret == 1)
		ret = ft_red_in(block, shell);
	if (block->redirect_out > 0 && ret == 1)
		ret = ft_red_out(block, shell);
	return (ret);
}

static int	ft_red_here(t_block *block)
{
	int	i;

	i = 0;
	while (block->limits[i])
	{
		ft_heredoc(block, block->limits[i]);
		i++;
	}
	dup2(block->heredoc_fd, 0);
	close(block->heredoc_fd);
	return (1);
}

static int	ft_red_in(t_block *block, t_shell *shell)
{
	int	i;

	i = 0;
	while (block->input[i])
	{
		block->redirect_in = open(block->input[i], O_RDONLY);
		if (block->redirect_in < 0)
		{
			perror(block->input[i]);
			shell->exit_status = 1;
			return (0);
		}
		i++;
		if (block->input[i])
			close(block->redirect_in);
	}
	dup2(block->redirect_in, STDIN_FILENO);
	close(block->redirect_in);
	return (1);
}

static int	ft_red_out(t_block *block, t_shell *shell)
{
	int	i;

	i = 0;
	while (block->output[i])
	{
		if (block->append)
			block->redirect_out = open(block->output[i], O_WRONLY
					| O_CREAT | O_APPEND, 0644);
		else
			block->redirect_out = open(block->output[i], O_WRONLY
					| O_CREAT | O_TRUNC, 0644);
		if (block->redirect_out < 0)
		{
			perror("open outfile");
			shell->exit_status = 1;
			return (0);
		}
		i++;
		if (block->output[i])
			close(block->redirect_out);
	}
	dup2(block->redirect_out, STDOUT_FILENO);
	close(block->redirect_out);
	return (1);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   simple_command.c                                   :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: lgertrud <lgertrud@student.42porto.com>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/08/06 13:54:43 by lgertrud          #+#    #+#             */
/*   Updated: 2025/08/21 11:34:57 by lgertrud         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

static void	ft_restore_std(int stdin_copy, int stdout_copy);
static void	ft_error_path(t_shell *shell, char *command);
static void	ft_wait(t_shell *shell, int status, int pid);

void	ft_simple_command(t_block *blocks, t_shell *shell)
{
	int		stdin_copy;
	int		stdout_copy;
	char	*path;

	stdin_copy = dup(STDOUT_FILENO);
	stdout_copy = dup(STDIN_FILENO);
	if (!ft_redirections(blocks, shell))
	{
		ft_restore_std(stdin_copy, stdout_copy);
		return ;
	}
	if (!ft_strcmp(blocks->args[0], "exit"))
		ft_restore_std(stdin_copy, stdout_copy);
	if (!ft_call_builtins(blocks, shell))
	{
		path = ft_found_path(blocks->args[0], shell->env);
		if (!path)
			ft_error_path(shell, blocks->args[0]);
		else
		{
			free(path);
			ft_simple_command_2(blocks, shell, stdin_copy, stdout_copy);
		}
	}
	ft_restore_std(stdin_copy, stdout_copy);
}

void	ft_simple_command_2(t_block *blocks,
		t_shell *shell, int fd_in, int fd_out)
{
	int		pid;
	char	*path;
	int		status;

	status = 0;
	path = ft_found_path(blocks->args[0], shell->env);
	pid = fork();
	if (pid == 0)
	{
		close(fd_in);
		close(fd_out);
		if (execve(path, blocks->args, shell->env) == -1)
		{
			ft_putstr_fd(blocks->args[0], STDERR_FILENO);
			ft_putendl_fd(": command not found", STDERR_FILENO);
			ft_free_blocks(blocks);
			free(path);
			ft_free_split(shell->env);
			free(shell);
			exit(127);
		}
	}
	ft_wait(shell, status, pid);
	if (path)
		free(path);
}

static void	ft_wait(t_shell *shell, int status, int pid)
{
	waitpid(pid, &status, 0);
	if (WIFEXITED(status))
		shell->exit_status = WEXITSTATUS(status);
	else if (WIFSIGNALED(status))
		shell->exit_status = 128 + WTERMSIG(status);
}

static void	ft_error_path(t_shell *shell, char *command)
{
	ft_putstr_fd(command, STDERR_FILENO);
	ft_putendl_fd(": command not found", STDERR_FILENO);
	shell->exit_status = 127;
}

static void	ft_restore_std(int stdin_copy, int stdout_copy)
{
	dup2(stdin_copy, STDOUT_FILENO);
	dup2(stdout_copy, STDIN_FILENO);
	close(stdin_copy);
	close(stdout_copy);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   blocks.c                                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: lgertrud <lgertrud@student.42porto.com>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/28 10:29:10 by lgertrud          #+#    #+#             */
/*   Updated: 2025/08/21 12:11:06 by lgertrud         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

static int	ft_fill_blk(t_block *blk, t_token **tk, t_shell *sh, t_block *head)
{
	int	i;

	i = 0;
	while (*tk && (*tk)->type != T_PIPE)
	{
		if ((*tk)->type == T_WORD)
			blk->args[i++] = ft_strdup((*tk)->value);
		else if ((*tk)->type == T_REDIRECT_IN
			|| (*tk)->type == T_REDIRECT_OUT || (*tk)->type == T_APPEND)
		{
			if (ft_handle_redirect(blk, tk, (*tk)->type) < 0)
				return (ft_redir_error(head, blk, sh));
		}
		else if ((*tk)->type == T_HEREDOC)
		{
			if (ft_handle_heredoc(blk, tk) < 0)
				return (ft_redir_error(head, blk, sh));
		}
		(*tk) = (*tk)->next;
	}
	blk->args[i] = NULL;
	return (0);
}

static int	ft_pipe_error(t_block *head, t_shell *shell)
{
	ft_free_blocks(head);
	ft_putendl_fd("minishell: pipe Error", 2);
	shell->exit_status = 1;
	return (-1);
}

void	ft_free_blocks(t_block *head)
{
	t_block	*tmp;

	if (!head)
		return ;
	while (head)
	{
		tmp = head->next;
		if (head->args)
			ft_free_split(head->args);
		if (head->input)
			ft_free_split(head->input);
		if (head->limits)
			ft_free_split(head->limits);
		if (head->output)
			ft_free_split(head->output);
		free(head);
		head = tmp;
	}
}

/// @brief 
/// @param token 
/// @param shell 
///	block [0] == head
///	block [1] == current
///	block [2] == new block
/// @return 
t_block	*ft_parse_blocks(t_token *token, t_shell *shell)
{
	t_block	*block[3];
	int		argc;

	block[0] = NULL;
	block[1] = NULL;
	while (token)
	{
		argc = ft_count_args(token);
		block[2] = ft_new_block(argc);
		if (!block[2] || ft_fill_blk(block[2], &token, shell, block[0]) < 0)
			return (NULL);
		if (!block[0])
			block[0] = block[2];
		else
			block[1]->next = block[2];
		block[1] = block[2];
		if (token && token->type == T_PIPE)
		{
			token = token->next;
			if (!token || token->type == T_PIPE)
				return (ft_pipe_error(block[0], shell), NULL);
		}
	}
	return (block[0]);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   blocks_utils.c                                     :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: lgertrud <lgertrud@student.42porto.com>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/28 10:29:10 by lgertrud          #+#    #+#             */
/*   Updated: 2025/08/21 12:31:42 by lgertrud         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

int	ft_count_args(t_token *tmp)
{
	int	argc;

	argc = 0;
	while (tmp && tmp->type != T_PIPE)
	{
		if (tmp->type == T_WORD)
			argc++;
		tmp = tmp->next;
	}
	return (argc);
}

t_block	*ft_new_block(int argc)
{
	t_block	*block;

	block = ft_calloc(1, sizeof(t_block));
	if (!block)
		return (NULL);
	block->args = ft_calloc(sizeof(char *), argc + 1);
	block->limits = ft_calloc(sizeof(char *), argc + 1);
	block->input = ft_calloc(sizeof(char *), argc + 1);
	block->output = ft_calloc(sizeof(char *), argc + 1);
	return (block);
}

int	ft_redir_error(t_block *head, t_block *blk, t_shell *shell)
{
	write(2, REDIREC_ERROR, ft_strlen(REDIREC_ERROR));
	ft_free_blocks(head);
	ft_free_blocks(blk);
	shell->exit_status = 2;
	return (-1);
}

int	ft_handle_redirect(t_block *block, t_token **token, int type)
{
	(*token) = (*token)->next;
	if (!(*token) || (*token)->type == T_PIPE || (*token)->type == T_REDIRECT_IN
		|| (*token)->type == T_REDIRECT_OUT || (*token)->type == T_APPEND || (*token)->type == T_HEREDOC)
		return (-1);
	if (type == T_REDIRECT_IN)
		block->input[block->redirect_in++] = ft_strdup((*token)->value);
	else
	{
		if (type == T_APPEND)
			block->append = 1;
		block->output[block->redirect_out++] = ft_strdup((*token)->value);
	}
	return (0);
}

int	ft_handle_heredoc(t_block *block, t_token **token)
{
	(*token) = (*token)->next;
	if (!(*token) || (*token)->type == T_PIPE || (*token)->type == T_REDIRECT_IN
		|| (*token)->type == T_REDIRECT_OUT || (*token)->type == T_APPEND || (*token)->type == T_HEREDOC)
		return (-1);
	block->limits[block->heredoc++] = ft_strdup((*token)->value);
	return (0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_environment_variable.c                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: lgertrud <lgertrud@student.42porto.com>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/13 16:47:03 by lgertrud          #+#    #+#             */
/*   Updated: 2025/08/21 11:53:44 by lgertrud         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

/// @brief this funcion take a environment variable and
///			set in one string 
/// @param env envinornment
/// @param part string where are the variable
/// @param code_exit exit code, if viariable is '?'
/// @return return new string, whit variable.
char	*ft_get_variable(char **env, char *part, int code_exit)
{
	char	*start;
	char	*var_name;
	char	*var_value;
	int		i;

	start = ft_strchr(part, '$');
	i = 1;
	if (!start[1])
		return (part);
	if (start[1] == '?')
		return (ft_concat(start, part, ft_itoa(code_exit), i + 1));
	if (start[1] == '{')
		return (ft_get_brace(env, part, start));
	while (start[i] && (ft_isalnum(start[i]) || start[i] == '_'))
		i++;
	var_name = ft_substr(start, 1, i - 1);
	var_value = get_env_value(env, var_name);
	free(var_name);
	return (ft_concat(start, part, var_value, i));
}

char	*get_env_value(char **env, const char *var_name)
{
	int	i;
	int	var_len;

	i = 0;
	var_len = ft_strlen(var_name);
	while (env[i])
	{
		if (!ft_strncmp(env[i], var_name, var_len) && env[i][var_len] == '=')
			return (ft_strdup(env[i] + var_len + 1));
		i++;
	}
	return (ft_strdup(""));
}

char	*ft_concat(char *start, char *part, char *var_value, int i)
{
	int		prefix_len;
	char	*prefix;
	char	*suffix;
	char	*tmp;
	char	*result;

	prefix_len = start - part;
	prefix = ft_substr(part, 0, prefix_len);
	suffix = ft_strdup(start + i);
	tmp = ft_strjoin(prefix, var_value);
	result = ft_strjoin(tmp, suffix);
	free(prefix);
	free(suffix);
	free(var_value);
	free(tmp);
	free(part);
	return (result);
}

/// @brief 
/// @param env 
/// @param part 
/// @param start 
/// @return 
char	*ft_get_brace(char **env, char *part, char *start)
{
	char	*end_brace;
	char	*var_name;
	char	*var_value;
	int		len;

	end_brace = ft_strchr(start + 2, '}');
	if (!end_brace)
	{
		free(part);
		return (ft_strdup(""));
	}
	len = end_brace - (start + 2);
	if (len == 0)
	{
		free(part);
		return (ft_strdup(""));
	}
	var_name = ft_substr(start + 2, 0, len);
	var_value = get_env_value(env, var_name);
	free(var_name);
	return (ft_concat(start, part, var_value, len + 3));
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   heredoc.c                                          :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: lgertrud <lgertrud@student.42porto.com>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/27 12:41:08 by ghenriqu          #+#    #+#             */
/*   Updated: 2025/07/28 11:59:25 by lgertrud         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

/// @brief the last part of the heredoc function executed by parent and child
/// @param pid the pid of that process, the parent or child process
/// @param fd the list of pipes that were created in the main part
/// @param token the structure that holds the token that were submited
/// @return if ok, return 0
static int	else_heredoc(pid_t pid, int *fd, t_block *block)
{
	int	status;

	close(fd[1]);
	waitpid(pid, &status, 0);
	if (WIFSIGNALED(status))
		return (WTERMSIG(status));
	block->heredoc_fd = fd[0];
	return (0);
}

/// @brief the function that holds the heredoc loop itself
/// @param fd the list of pipes that were created in the main part
/// @param limiter the EOF of the heredoc
/// @return if ok, return 0
static int	if_heredoc(int *fd, char *limiter)
{
	char	*line;

	signal(SIGINT, SIG_DFL);
	close(fd[0]);
	while (1)
	{
		line = readline("> ");
		if (!line || ft_strcmp(line, limiter) == 0)
		{
			free(line);
			break ;
		}
		write(fd[1], line, ft_strlen(line));
		write(fd[1], "\n", 1);
		free(line);
	}
	close(fd[1]);
	exit(0);
	return (0);
}

/// @brief the function that orchestrates the heredoc call in our minishell
/// @param token the structure that holds the token that were submited
/// @return if ok, return 0
int	ft_heredoc(t_block *block, char *limiter)
{
	int		fd[2];
	pid_t	pid;

	if (!block || !limiter)
		return (-1);
	if (pipe(fd) == -1)
		return (-1);
	pid = fork();
	if (pid == -1)
		return (-1);
	if (pid == 0)
		if_heredoc(fd, limiter);
	else_heredoc(pid, fd, block);
	return (0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   main.c                                             :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: lgertrud <lgertrud@student.42porto.com>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/03 21:33:12 by lgertrud          #+#    #+#             */
/*   Updated: 2025/08/21 14:27:00 by lgertrud         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

t_shell	*g_shell;

/// @brief Handles the SIGINT signal (Ctrl-C) by clearing the current input line
///        and redisplaying the prompt without exiting the shell.
/// @param sig The signal number (unused in this function).
void	ft_handle_sigint(int sig)
{
	(void)sig;
	if (g_shell)
		g_shell->exit_status = 130;
	rl_replace_line("", 0);
	write(1, "\n", 1);
	rl_on_new_line();
	rl_redisplay();
}

/// @brief Sets up custom signal handlers for interactive shell behavior.
///        Specifically, handles SIGINT and ignores SIGQUIT.
/// @param void This function takes no parameters.
static void	ft_setup_signals(void)
{
	signal(SIGINT, ft_handle_sigint);
	signal(SIGQUIT, SIG_IGN);
}

/// @brief in this function we determine if is a terminal or not
/// @return 1 = is a tty, 0 = it isn't a terminal
static int	check_interactive(void)
{
	if (isatty(STDIN_FILENO))
		return (1);
	return (0);
}

/// @brief 
/// @param shell 
/// @param env 
static void	minishell_loop(t_shell *shell, char **env)
{
	char	*line;
	t_block	*blocks;

	while (1)
	{
		if (check_interactive())
			line = readline(MINI);
		else
			line = get_next_line(STDIN_FILENO);
		if (!line)
		{
			if (check_interactive())
				ft_putendl_fd("exit", STDOUT_FILENO);
			break ;
		}
		if (*line)
			add_history(line);
		blocks = ft_tokenizer(shell, line, env);
		if (blocks)
			ft_minishell(blocks, shell);
		ft_free_blocks(blocks);
		free(line);
	}
}

/// @brief Read line, create history, check signal ctrl-C and call tokenizer
/// @return value exit
int	main(int argc, char **argv, char **env)
{
	t_shell	*shell;

	shell = NULL;
	shell = ft_init_shell(shell, env);
	(void)argc;
	(void)argv;
	g_shell = shell;
	ft_setup_signals();
	minishell_loop(shell, env);
	ft_free_split(shell->env);
	ft_free_split(shell->export);
	free(shell);
	rl_clear_history();
	return (0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   parser_to_builtins.c                               :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ghenriqu <ghenriqu@student.42porto.com>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/11 13:13:19 by lgertrud          #+#    #+#             */
/*   Updated: 2025/08/16 14:04:16 by ghenriqu         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

static int	ft_print_error(t_shell *shell, char *path, char *str, int code);

/// @brief this function call ant builtin according to input
/// @param token tokens of the input
/// @param env variable ambient
/// @return return 1 if succed, or 0 if is fail
int	ft_call_builtins(t_block *block, t_shell *shell)
{
	if (!block->args || !block->args[0])
		return (0);
	if (!ft_strcmp(block->args[0], "pwd"))
		ft_pwd(block->args + 1, shell->env);
	else if (!ft_strcmp(block->args[0], "echo"))
		shell->exit_status = ft_echo(block->args + 1);
	else if (!ft_strcmp(block->args[0], "env"))
		ft_env(block->args + 1, shell->env);
	else if (!ft_strcmp(block->args[0], "exit"))
		ft_exit(block->args + 1, shell, block);
	else if (!ft_strcmp(block->args[0], "export"))
		ft_export(block->args + 1, shell);
	else if (!ft_strcmp(block->args[0], "unset"))
		ft_unset(block->args + 1, shell);
	else if (!ft_strcmp(block->args[0], "cd"))
		shell->exit_status = ft_cd(block->args + 1, shell);
	else if (ft_strchr(block->args[0], 47))
	{
		if (!is_directory(block->args[0], shell))
			return (0);
	}
	else
		return (0);
	return (1);
}

/// @brief free any array of the arrays
/// @param arr array of the arrays
void	ft_free_split(char **arr)
{
	int	i;

	i = 0;
	while (arr[i])
	{
		free(arr[i]);
		i++;
	}
	free(arr);
}

int	is_directory(char *path, t_shell *shell)
{
	struct stat	sb;

	if (stat(path, &sb) == -1)
		return (ft_print_error(shell,
				path, ": No such file or directory", 127));
	else if (S_ISDIR(sb.st_mode))
		return (ft_print_error(shell, path, ": Is a directory", 126));
	else if (S_ISREG(sb.st_mode))
	{
		if (access(path, X_OK) == 0)
			return (0);
		else
			ft_print_error(shell, path, ": Permission denied", 126);
		return (1);
	}
	ft_print_error(shell, path, ": Not a directory", 127);
	return (1);
}

static int	ft_print_error(t_shell *shell, char *path, char *str, int code)
{
	ft_putstr_fd("minishell: ", 2);
	ft_putstr_fd(path, 2);
	ft_putendl_fd(str, 2);
	shell->exit_status = code;
	return (1);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   token.c                                            :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: lgertrud <lgertrud@student.42porto.com>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/08 18:25:51 by lgertrud          #+#    #+#             */
/*   Updated: 2025/08/21 11:54:14 by lgertrud         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

static t_token	*ft_init_token_2(t_shell *shell, t_token *head,
					char *line, int *i);
static void		ft_init_token_3(t_token **new, t_token **head,
					t_token **current);

/// @brief init token and call built functons
/// @param line is the param that user write
/// @param env ambient variable
/// @return the token created
t_block	*ft_tokenizer(t_shell *shell, char *line, char **env)
{
	t_token	*token;
	t_block	*blocks;

	(void)env;
	blocks = NULL;
	if (!line[0] || !ft_have_something(line) || !ft_strcmp(line, "$EMPTY"))
		return (NULL);
	if (!ft_strncmp(line, "$EMPTY", 6))
		line += 6;
	if (!ft_strncmp(line, "\"\"", 2) && (!line[2] || line[2] == 32))
	{
		ft_putendl_fd(": command not found", STDERR_FILENO);
		shell->exit_status = 127;
		return (NULL);
	}
	token = ft_init_token(shell, line);
	if (!token)
	{
		printf(INPUT_ERROR);
		return (NULL);
	}
	blocks = ft_parse_blocks(token, shell);
	ft_free_tokens(token);
	return (blocks);
}

/// @brief tokenization, alloc the memory and call functions for value and type
/// @param line is the user input
/// @return return token created or NULL if input is invalid
t_token	*ft_init_token(t_shell *shell, char *line)
{
	t_token	*head;
	t_token	*current;
	t_token	*new;
	int		i;

	head = NULL;
	current = NULL;
	i = 0;
	while (line[i])
	{
		if (line[i] == ' ' || line[i] == '\t')
			i++;
		else
		{
			new = ft_init_token_2(shell, head, line, &i);
			if (!new)
				return (NULL);
			ft_init_token_3(&new, &head, &current);
		}
	}
	return (head);
}

/// @brief if the atual character is a delimiter, created a token
/// 		else, call function get value.
/// @param new is a new node
/// @param head head to linked list
/// @param line input user
/// @param i interator that we used to walk string
/// @return return 0 for error or 1 if was been succeed
static t_token	*ft_init_token_2(t_shell *shell, t_token *head,
					char *line, int *i)
{
	t_token	*new;

	new = ft_calloc(sizeof(t_token), 1);
	if (!new)
		ft_error(head, MALLOC_ERROR, 1);
	if ((line[*i] == '>' && line[*i + 1] == '>')
		|| (line[*i] == '<' && line[*i + 1] == '<'))
	{
		new->value = ft_substr(line, *i, 2);
		(*i) += 2;
	}
	else if (ft_is_delimiter(line[*i]))
	{
		new->value = ft_substr(line, (*i), 1);
		(*i)++;
	}
	else
		new->value = ft_get_value(shell, line, i);
	if (!new->value)
	{
		ft_free_tokens(head);
		free(new);
		return (NULL);
	}
	return (new);
}

/// @brief call the get type and update current
/// @param new new node
/// @param head declare head, if it has not been declared
/// @param current variable used to walk inside list
static void	ft_init_token_3(t_token **new, t_token **head, t_token **current)
{
	(*new)->type = ft_get_type((*new)->value);
	(*new)->next = NULL;
	if (!*head)
	{
		*head = *new;
		*current = *new;
	}
	else
	{
		(*current)->next = *new;
		*current = *new;
	}
}

int	ft_have_something(char *line)
{
	int	i;

	i = 0;
	while (line[i] && (line[i] == 32 || line[i] == '\t'))
		i++;
	if (line[i])
		return (1);
	return (0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   token_utils.c                                      :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: lgertrud <lgertrud@student.42porto.com>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/10 16:48:31 by lgertrud          #+#    #+#             */
/*   Updated: 2025/07/22 14:19:12 by lgertrud         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

static char	*ft_get_value_2(t_shell *shell, const char *s, int *i);
static char	*ft_expand_variables(char *part, t_shell *shell, char quote);

/// @brief Extracts the next token
///			(word or quoted string) from the input string.
/// @param s The input string to parse.
/// @param i A pointer to the current position in the string (will be updated).
/// @return A newly allocated substring containing the extracted token.
char	*ft_get_value(t_shell *shell, const char *s, int *i)
{
	char	*result;
	char	*part;
	char	*tmp;

	result = NULL;
	while (s[*i] && s[*i] != ' ' && s[*i] != '\t' && !ft_is_delimiter(s[*i]))
	{
		part = ft_get_value_2(shell, s, i);
		if (!part)
		{
			free(result);
			return (NULL);
		}
		tmp = result;
		if (result)
			result = ft_strjoin(result, part);
		else
			result = ft_strdup(part);
		free(tmp);
		free(part);
	}
	return (result);
}

/// @brief Extracts a single token part:
///			either a quoted string or a plain word fragment.
///       	 Handles opening/closing quotes and
///				advances the parsing index accordingly.
/// @param s The input string being parsed.
/// @param i A pointer to the current index in the string. Will be updated.
/// @return A newly allocated substring for this part
///				or NULL if unterminated quote or malloc fails.
static char	*ft_get_value_2(t_shell *shell, const char *s, int *i)
{
	int		start;
	char	quote;
	char	*part;

	quote = 0;
	if (s[*i] == '"' || s[*i] == '\'')
	{
		quote = s[(*i)++];
		start = *i;
		while (s[*i] && s[*i] != quote)
			(*i)++;
		if (s[*i] != quote)
			return (NULL);
		part = ft_substr(s, start, (*i)++ - start);
	}
	else
	{
		start = *i;
		while (s[*i] && s[*i] != '"' && s[*i] != '\''
			&& s[*i] != ' ' && s[*i] != '\t' && !ft_is_delimiter(s[*i]))
			(*i)++;
		part = ft_substr(s, start, *i - start);
	}
	part = ft_expand_variables(part, shell, quote);
	return (part);
}

static char	*ft_expand_variables(char *part, t_shell *shell, char quote)
{
	char	*pointer;

	while (quote != '\'' && ft_strchr(part, '$'))
	{
		pointer = ft_strchr(part, '$');
		if (!pointer[1] || pointer[1] == ' ' || ft_is_delimiter(pointer[1]))
			break ;
		part = ft_get_variable(shell->env, part, shell->exit_status);
	}
	return (part);
}

/// @brief this functions define the type of the value
/// @param value value of type that we will find
/// @return The type of the argument
t_type	ft_get_type(char *value)
{
	if (!ft_strncmp(">", value, ft_strlen(value)) && value[0])
		return (T_REDIRECT_OUT);
	else if (!ft_strncmp(">>", value, ft_strlen(value)) && value[0])
		return (T_APPEND);
	else if (!ft_strncmp("<", value, ft_strlen(value)) && value[0])
		return (T_REDIRECT_IN);
	else if (!ft_strncmp("|", value, ft_strlen(value)) && value[0])
		return (T_PIPE);
	else if (!ft_strncmp("<<", value, ft_strlen(value)) && value[0])
		return (T_HEREDOC);
	else
		return (T_WORD);
}

/// @brief if the param is a delimiter, return 1 else 0
int	ft_is_delimiter(char c)
{
	return (c == '>' || c == '<' || c == '|');
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   utils.c                                            :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: lgertrud <lgertrud@student.42porto.com>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/09 19:54:58 by lgertrud          #+#    #+#             */
/*   Updated: 2025/08/21 14:15:39 by lgertrud         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

/// @brief free struct
void	ft_free_tokens(t_token *token)
{
	t_token	*tmp;

	while (token)
	{
		tmp = token->next;
		if (token->value)
			free(token->value);
		free(token);
		token = tmp;
	}
}

/// @brief function for errors
/// @param token token for free
/// @param message message error
/// @param code exit code
void	ft_error(t_token *token, char *message, int code)
{
	if (token)
		ft_free_tokens(token);
	ft_putendl_fd(message, 2);
	exit (code);
}

/// @brief this function counts how many nodes there are in a struct
/// @param env ambient variable
/// @return the count
int	ft_lstsize(t_token *lst)
{
	int	i;

	i = 0;
	while (lst)
	{
		lst = lst->next;
		i++;
	}
	return (i);
}

/// @brief this function create a copy of env whit memory alloc
/// @param envp envp
/// @return copy
char	**ft_copy_env(char **envp)
{
	int		i;
	char	**new_env;

	i = 0;
	while (envp[i])
		i++;
	new_env = malloc(sizeof(char *) * (i + 1));
	if (!new_env)
		return (NULL);
	i = 0;
	while (envp[i])
	{
		new_env[i] = ft_strdup(envp[i]);
		i++;
	}
	new_env[i] = NULL;
	return (new_env);
}

t_shell	*ft_init_shell(t_shell *shell, char **env)
{
	shell = malloc(sizeof(t_shell));
	shell->exit_status = 0;
	shell->env = ft_copy_env(env);
	shell->export = ft_copy_env(env);
	return (shell);
}
/*
// provisorie function, we will delete it latter
char	*name_type(int type)
{
	if (type == 0)
		return ("WORD");
	if (type == 1)
		return ("PIPE");
	if (type == 2)
		return ("REDIRECT_IN");
	if (type == 3)
		return ("REDIRECT_OUT");
	if (type == 4)
		return ("APPEND");
	return ("HEREDOC");
}

// provisorie function, we will delete it latter
void	print_token(t_token *token)
{
	t_token	*current;
	int		i;

	current = token;
	i = 0;
	printf("------------------------\n");
	printf("-------TOKENS-----------\n");
	printf("------------------------\n");
	while (current)
	{
		printf("TOKEN[%d]\n", i);
		printf("value -> %s\n", current->value);
		printf("type -> %s\n", name_type(current->type));
		printf("-----------\n");
		i++;
		current = current->next;
	}
}
*/